{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nimport isAbsent from './util/isAbsent';\nimport isSchema from './util/isSchema';\nimport printValue from './util/printValue';\nimport { array as locale } from './locale';\nimport runTests from './util/runTests';\nimport ValidationError from './ValidationError';\nimport BaseSchema from './schema';\nexport function create(type) {\n  return new ArraySchema(type);\n}\nexport default class ArraySchema extends BaseSchema {\n  constructor(type) {\n    super({\n      type: 'array'\n    }); // `undefined` specifically means uninitialized, as opposed to\n    // \"no subtype\"\n\n    this.innerType = type;\n    this.withMutation(() => {\n      this.transform(function (values) {\n        if (typeof values === 'string') try {\n          values = JSON.parse(values);\n        } catch (err) {\n          values = null;\n        }\n        return this.isType(values) ? values : null;\n      });\n    });\n  }\n\n  _typeCheck(v) {\n    return Array.isArray(v);\n  }\n\n  get _subType() {\n    return this.innerType;\n  }\n\n  _cast(_value, _opts) {\n    const value = super._cast(_value, _opts); //should ignore nulls here\n\n\n    if (!this._typeCheck(value) || !this.innerType) return value;\n    let isChanged = false;\n    const castArray = value.map((v, idx) => {\n      const castElement = this.innerType.cast(v, _extends({}, _opts, {\n        path: `${_opts.path || ''}[${idx}]`\n      }));\n\n      if (castElement !== v) {\n        isChanged = true;\n      }\n\n      return castElement;\n    });\n    return isChanged ? castArray : value;\n  }\n\n  _validate(_value, options = {}, callback) {\n    var _options$abortEarly, _options$recursive;\n\n    let errors = [];\n    let sync = options.sync;\n    let path = options.path;\n    let innerType = this.innerType;\n    let endEarly = (_options$abortEarly = options.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly;\n    let recursive = (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive;\n    let originalValue = options.originalValue != null ? options.originalValue : _value;\n\n    super._validate(_value, options, (err, value) => {\n      if (err) {\n        if (!ValidationError.isError(err) || endEarly) {\n          return void callback(err, value);\n        }\n\n        errors.push(err);\n      }\n\n      if (!recursive || !innerType || !this._typeCheck(value)) {\n        callback(errors[0] || null, value);\n        return;\n      }\n\n      originalValue = originalValue || value; // #950 Ensure that sparse array empty slots are validated\n\n      let tests = new Array(value.length);\n\n      for (let idx = 0; idx < value.length; idx++) {\n        let item = value[idx];\n        let path = `${options.path || ''}[${idx}]`; // object._validate note for isStrict explanation\n\n        let innerOptions = _extends({}, options, {\n          path,\n          strict: true,\n          parent: value,\n          index: idx,\n          originalValue: originalValue[idx]\n        });\n\n        tests[idx] = (_, cb) => innerType.validate(item, innerOptions, cb);\n      }\n\n      runTests({\n        sync,\n        path,\n        value,\n        errors,\n        endEarly,\n        tests\n      }, callback);\n    });\n  }\n\n  clone(spec) {\n    const next = super.clone(spec);\n    next.innerType = this.innerType;\n    return next;\n  }\n\n  concat(schema) {\n    let next = super.concat(schema);\n    next.innerType = this.innerType;\n    if (schema.innerType) next.innerType = next.innerType ? // @ts-expect-error Lazy doesn't have concat()\n    next.innerType.concat(schema.innerType) : schema.innerType;\n    return next;\n  }\n\n  of(schema) {\n    // FIXME: this should return a new instance of array without the default to be\n    var next = this.clone();\n    if (!isSchema(schema)) throw new TypeError('`array.of()` sub-schema must be a valid yup schema not: ' + printValue(schema)); // FIXME(ts):\n\n    next.innerType = schema;\n    return next;\n  }\n\n  length(length, message = locale.length) {\n    return this.test({\n      message,\n      name: 'length',\n      exclusive: true,\n      params: {\n        length\n      },\n\n      test(value) {\n        return isAbsent(value) || value.length === this.resolve(length);\n      }\n\n    });\n  }\n\n  min(min, message) {\n    message = message || locale.min;\n    return this.test({\n      message,\n      name: 'min',\n      exclusive: true,\n      params: {\n        min\n      },\n\n      // FIXME(ts): Array<typeof T>\n      test(value) {\n        return isAbsent(value) || value.length >= this.resolve(min);\n      }\n\n    });\n  }\n\n  max(max, message) {\n    message = message || locale.max;\n    return this.test({\n      message,\n      name: 'max',\n      exclusive: true,\n      params: {\n        max\n      },\n\n      test(value) {\n        return isAbsent(value) || value.length <= this.resolve(max);\n      }\n\n    });\n  }\n\n  ensure() {\n    return this.default(() => []).transform((val, original) => {\n      // We don't want to return `null` for nullable schema\n      if (this._typeCheck(val)) return val;\n      return original == null ? [] : [].concat(original);\n    });\n  }\n\n  compact(rejector) {\n    let reject = !rejector ? v => !!v : (v, i, a) => !rejector(v, i, a);\n    return this.transform(values => values != null ? values.filter(reject) : values);\n  }\n\n  describe() {\n    let base = super.describe();\n    if (this.innerType) base.innerType = this.innerType.describe();\n    return base;\n  }\n\n}\ncreate.prototype = ArraySchema.prototype; //\n// Interfaces\n//","map":{"version":3,"sources":["/home/jun/foodbank/node_modules/yup/es/array.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","isAbsent","isSchema","printValue","array","locale","runTests","ValidationError","BaseSchema","create","type","ArraySchema","constructor","innerType","withMutation","transform","values","JSON","parse","err","isType","_typeCheck","v","Array","isArray","_subType","_cast","_value","_opts","value","isChanged","castArray","map","idx","castElement","cast","path","_validate","options","callback","_options$abortEarly","_options$recursive","errors","sync","endEarly","abortEarly","spec","recursive","originalValue","isError","push","tests","item","innerOptions","strict","parent","index","_","cb","validate","clone","next","concat","schema","of","TypeError","message","test","name","exclusive","params","resolve","min","max","ensure","default","val","original","compact","rejector","reject","a","filter","describe","base"],"mappings":"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","sourcesContent":["function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport isAbsent from './util/isAbsent';\nimport isSchema from './util/isSchema';\nimport printValue from './util/printValue';\nimport { array as locale } from './locale';\nimport runTests from './util/runTests';\nimport ValidationError from './ValidationError';\nimport BaseSchema from './schema';\nexport function create(type) {\n  return new ArraySchema(type);\n}\nexport default class ArraySchema extends BaseSchema {\n  constructor(type) {\n    super({\n      type: 'array'\n    }); // `undefined` specifically means uninitialized, as opposed to\n    // \"no subtype\"\n\n    this.innerType = type;\n    this.withMutation(() => {\n      this.transform(function (values) {\n        if (typeof values === 'string') try {\n          values = JSON.parse(values);\n        } catch (err) {\n          values = null;\n        }\n        return this.isType(values) ? values : null;\n      });\n    });\n  }\n\n  _typeCheck(v) {\n    return Array.isArray(v);\n  }\n\n  get _subType() {\n    return this.innerType;\n  }\n\n  _cast(_value, _opts) {\n    const value = super._cast(_value, _opts); //should ignore nulls here\n\n\n    if (!this._typeCheck(value) || !this.innerType) return value;\n    let isChanged = false;\n    const castArray = value.map((v, idx) => {\n      const castElement = this.innerType.cast(v, _extends({}, _opts, {\n        path: `${_opts.path || ''}[${idx}]`\n      }));\n\n      if (castElement !== v) {\n        isChanged = true;\n      }\n\n      return castElement;\n    });\n    return isChanged ? castArray : value;\n  }\n\n  _validate(_value, options = {}, callback) {\n    var _options$abortEarly, _options$recursive;\n\n    let errors = [];\n    let sync = options.sync;\n    let path = options.path;\n    let innerType = this.innerType;\n    let endEarly = (_options$abortEarly = options.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly;\n    let recursive = (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive;\n    let originalValue = options.originalValue != null ? options.originalValue : _value;\n\n    super._validate(_value, options, (err, value) => {\n      if (err) {\n        if (!ValidationError.isError(err) || endEarly) {\n          return void callback(err, value);\n        }\n\n        errors.push(err);\n      }\n\n      if (!recursive || !innerType || !this._typeCheck(value)) {\n        callback(errors[0] || null, value);\n        return;\n      }\n\n      originalValue = originalValue || value; // #950 Ensure that sparse array empty slots are validated\n\n      let tests = new Array(value.length);\n\n      for (let idx = 0; idx < value.length; idx++) {\n        let item = value[idx];\n        let path = `${options.path || ''}[${idx}]`; // object._validate note for isStrict explanation\n\n        let innerOptions = _extends({}, options, {\n          path,\n          strict: true,\n          parent: value,\n          index: idx,\n          originalValue: originalValue[idx]\n        });\n\n        tests[idx] = (_, cb) => innerType.validate(item, innerOptions, cb);\n      }\n\n      runTests({\n        sync,\n        path,\n        value,\n        errors,\n        endEarly,\n        tests\n      }, callback);\n    });\n  }\n\n  clone(spec) {\n    const next = super.clone(spec);\n    next.innerType = this.innerType;\n    return next;\n  }\n\n  concat(schema) {\n    let next = super.concat(schema);\n    next.innerType = this.innerType;\n    if (schema.innerType) next.innerType = next.innerType ? // @ts-expect-error Lazy doesn't have concat()\n    next.innerType.concat(schema.innerType) : schema.innerType;\n    return next;\n  }\n\n  of(schema) {\n    // FIXME: this should return a new instance of array without the default to be\n    var next = this.clone();\n    if (!isSchema(schema)) throw new TypeError('`array.of()` sub-schema must be a valid yup schema not: ' + printValue(schema)); // FIXME(ts):\n\n    next.innerType = schema;\n    return next;\n  }\n\n  length(length, message = locale.length) {\n    return this.test({\n      message,\n      name: 'length',\n      exclusive: true,\n      params: {\n        length\n      },\n\n      test(value) {\n        return isAbsent(value) || value.length === this.resolve(length);\n      }\n\n    });\n  }\n\n  min(min, message) {\n    message = message || locale.min;\n    return this.test({\n      message,\n      name: 'min',\n      exclusive: true,\n      params: {\n        min\n      },\n\n      // FIXME(ts): Array<typeof T>\n      test(value) {\n        return isAbsent(value) || value.length >= this.resolve(min);\n      }\n\n    });\n  }\n\n  max(max, message) {\n    message = message || locale.max;\n    return this.test({\n      message,\n      name: 'max',\n      exclusive: true,\n      params: {\n        max\n      },\n\n      test(value) {\n        return isAbsent(value) || value.length <= this.resolve(max);\n      }\n\n    });\n  }\n\n  ensure() {\n    return this.default(() => []).transform((val, original) => {\n      // We don't want to return `null` for nullable schema\n      if (this._typeCheck(val)) return val;\n      return original == null ? [] : [].concat(original);\n    });\n  }\n\n  compact(rejector) {\n    let reject = !rejector ? v => !!v : (v, i, a) => !rejector(v, i, a);\n    return this.transform(values => values != null ? values.filter(reject) : values);\n  }\n\n  describe() {\n    let base = super.describe();\n    if (this.innerType) base.innerType = this.innerType.describe();\n    return base;\n  }\n\n}\ncreate.prototype = ArraySchema.prototype; //\n// Interfaces\n//"]},"metadata":{},"sourceType":"module"}