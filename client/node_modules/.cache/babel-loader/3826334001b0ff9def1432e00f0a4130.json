{"ast":null,"code":"import { number as locale } from './locale';\nimport isAbsent from './util/isAbsent';\nimport BaseSchema from './schema';\n\nlet isNaN = value => value != +value;\n\nexport function create() {\n  return new NumberSchema();\n}\nexport default class NumberSchema extends BaseSchema {\n  constructor() {\n    super({\n      type: 'number'\n    });\n    this.withMutation(() => {\n      this.transform(function (value) {\n        let parsed = value;\n\n        if (typeof parsed === 'string') {\n          parsed = parsed.replace(/\\s/g, '');\n          if (parsed === '') return NaN; // don't use parseFloat to avoid positives on alpha-numeric strings\n\n          parsed = +parsed;\n        }\n\n        if (this.isType(parsed)) return parsed;\n        return parseFloat(parsed);\n      });\n    });\n  }\n\n  _typeCheck(value) {\n    if (value instanceof Number) value = value.valueOf();\n    return typeof value === 'number' && !isNaN(value);\n  }\n\n  min(min, message = locale.min) {\n    return this.test({\n      message,\n      name: 'min',\n      exclusive: true,\n      params: {\n        min\n      },\n\n      test(value) {\n        return isAbsent(value) || value >= this.resolve(min);\n      }\n\n    });\n  }\n\n  max(max, message = locale.max) {\n    return this.test({\n      message,\n      name: 'max',\n      exclusive: true,\n      params: {\n        max\n      },\n\n      test(value) {\n        return isAbsent(value) || value <= this.resolve(max);\n      }\n\n    });\n  }\n\n  lessThan(less, message = locale.lessThan) {\n    return this.test({\n      message,\n      name: 'max',\n      exclusive: true,\n      params: {\n        less\n      },\n\n      test(value) {\n        return isAbsent(value) || value < this.resolve(less);\n      }\n\n    });\n  }\n\n  moreThan(more, message = locale.moreThan) {\n    return this.test({\n      message,\n      name: 'min',\n      exclusive: true,\n      params: {\n        more\n      },\n\n      test(value) {\n        return isAbsent(value) || value > this.resolve(more);\n      }\n\n    });\n  }\n\n  positive(msg = locale.positive) {\n    return this.moreThan(0, msg);\n  }\n\n  negative(msg = locale.negative) {\n    return this.lessThan(0, msg);\n  }\n\n  integer(message = locale.integer) {\n    return this.test({\n      name: 'integer',\n      message,\n      test: val => isAbsent(val) || Number.isInteger(val)\n    });\n  }\n\n  truncate() {\n    return this.transform(value => !isAbsent(value) ? value | 0 : value);\n  }\n\n  round(method) {\n    var _method;\n\n    var avail = ['ceil', 'floor', 'round', 'trunc'];\n    method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || 'round'; // this exists for symemtry with the new Math.trunc\n\n    if (method === 'trunc') return this.truncate();\n    if (avail.indexOf(method.toLowerCase()) === -1) throw new TypeError('Only valid options for round() are: ' + avail.join(', '));\n    return this.transform(value => !isAbsent(value) ? Math[method](value) : value);\n  }\n\n}\ncreate.prototype = NumberSchema.prototype; //\n// Number Interfaces\n//","map":{"version":3,"sources":["/home/jun/foodbank/node_modules/yup/es/number.js"],"names":["number","locale","isAbsent","BaseSchema","isNaN","value","create","NumberSchema","constructor","type","withMutation","transform","parsed","replace","NaN","isType","parseFloat","_typeCheck","Number","valueOf","min","message","test","name","exclusive","params","resolve","max","lessThan","less","moreThan","more","positive","msg","negative","integer","val","isInteger","truncate","round","method","_method","avail","toLowerCase","indexOf","TypeError","join","Math","prototype"],"mappings":"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","sourcesContent":["import { number as locale } from './locale';\nimport isAbsent from './util/isAbsent';\nimport BaseSchema from './schema';\n\nlet isNaN = value => value != +value;\n\nexport function create() {\n  return new NumberSchema();\n}\nexport default class NumberSchema extends BaseSchema {\n  constructor() {\n    super({\n      type: 'number'\n    });\n    this.withMutation(() => {\n      this.transform(function (value) {\n        let parsed = value;\n\n        if (typeof parsed === 'string') {\n          parsed = parsed.replace(/\\s/g, '');\n          if (parsed === '') return NaN; // don't use parseFloat to avoid positives on alpha-numeric strings\n\n          parsed = +parsed;\n        }\n\n        if (this.isType(parsed)) return parsed;\n        return parseFloat(parsed);\n      });\n    });\n  }\n\n  _typeCheck(value) {\n    if (value instanceof Number) value = value.valueOf();\n    return typeof value === 'number' && !isNaN(value);\n  }\n\n  min(min, message = locale.min) {\n    return this.test({\n      message,\n      name: 'min',\n      exclusive: true,\n      params: {\n        min\n      },\n\n      test(value) {\n        return isAbsent(value) || value >= this.resolve(min);\n      }\n\n    });\n  }\n\n  max(max, message = locale.max) {\n    return this.test({\n      message,\n      name: 'max',\n      exclusive: true,\n      params: {\n        max\n      },\n\n      test(value) {\n        return isAbsent(value) || value <= this.resolve(max);\n      }\n\n    });\n  }\n\n  lessThan(less, message = locale.lessThan) {\n    return this.test({\n      message,\n      name: 'max',\n      exclusive: true,\n      params: {\n        less\n      },\n\n      test(value) {\n        return isAbsent(value) || value < this.resolve(less);\n      }\n\n    });\n  }\n\n  moreThan(more, message = locale.moreThan) {\n    return this.test({\n      message,\n      name: 'min',\n      exclusive: true,\n      params: {\n        more\n      },\n\n      test(value) {\n        return isAbsent(value) || value > this.resolve(more);\n      }\n\n    });\n  }\n\n  positive(msg = locale.positive) {\n    return this.moreThan(0, msg);\n  }\n\n  negative(msg = locale.negative) {\n    return this.lessThan(0, msg);\n  }\n\n  integer(message = locale.integer) {\n    return this.test({\n      name: 'integer',\n      message,\n      test: val => isAbsent(val) || Number.isInteger(val)\n    });\n  }\n\n  truncate() {\n    return this.transform(value => !isAbsent(value) ? value | 0 : value);\n  }\n\n  round(method) {\n    var _method;\n\n    var avail = ['ceil', 'floor', 'round', 'trunc'];\n    method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || 'round'; // this exists for symemtry with the new Math.trunc\n\n    if (method === 'trunc') return this.truncate();\n    if (avail.indexOf(method.toLowerCase()) === -1) throw new TypeError('Only valid options for round() are: ' + avail.join(', '));\n    return this.transform(value => !isAbsent(value) ? Math[method](value) : value);\n  }\n\n}\ncreate.prototype = NumberSchema.prototype; //\n// Number Interfaces\n//"]},"metadata":{},"sourceType":"module"}