{"ast":null,"code":"function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { fromObject, scale, transform, translate } from 'transformation-matrix';\nimport { ACTION_ZOOM, MODE_IDLE, MODE_ZOOMING, ALIGN_CENTER, ALIGN_LEFT, ALIGN_RIGHT, ALIGN_TOP, ALIGN_BOTTOM, ALIGN_COVER } from '../constants';\nimport { decompose, getSVGPoint, set } from './common';\nimport calculateBox from '../utils/calculateBox';\nexport function isZoomLevelGoingOutOfBounds(value, scaleFactor) {\n  var _decompose = decompose(value),\n      curScaleFactor = _decompose.scaleFactor;\n\n  var lessThanScaleFactorMin = value.scaleFactorMin && curScaleFactor * scaleFactor < value.scaleFactorMin;\n  var moreThanScaleFactorMax = value.scaleFactorMax && curScaleFactor * scaleFactor > value.scaleFactorMax;\n  return lessThanScaleFactorMin && scaleFactor < 1 || moreThanScaleFactorMax && scaleFactor > 1;\n}\nexport function limitZoomLevel(value, matrix) {\n  var scaleLevel = matrix.a;\n\n  if (value.scaleFactorMin != null) {\n    // limit minimum zoom\n    scaleLevel = Math.max(scaleLevel, value.scaleFactorMin);\n  }\n\n  if (value.scaleFactorMax != null) {\n    // limit maximum zoom\n    scaleLevel = Math.min(scaleLevel, value.scaleFactorMax);\n  }\n\n  return set(matrix, {\n    a: scaleLevel,\n    d: scaleLevel\n  });\n}\nexport function zoom(value, SVGPointX, SVGPointY, scaleFactor) {\n  if (isZoomLevelGoingOutOfBounds(value, scaleFactor)) {\n    // Do not change translation and scale of value\n    return value;\n  }\n\n  var matrix = transform(fromObject(value), translate(SVGPointX, SVGPointY), scale(scaleFactor, scaleFactor), translate(-SVGPointX, -SVGPointY));\n  return set(value, _objectSpread(_objectSpread({\n    mode: MODE_IDLE\n  }, matrix), {}, {\n    startX: null,\n    startY: null,\n    endX: null,\n    endY: null\n  }), ACTION_ZOOM);\n} //ENHANCEMENT: add ability to control alignment\n//ENHANCEMENT: add ability to selectively fit image inside viewer\n//ENHANCEMENT: refactor some logic in order to merge with fitToViewer function\n\nexport function fitSelection(value, selectionSVGPointX, selectionSVGPointY, selectionWidth, selectionHeight) {\n  var viewerWidth = value.viewerWidth,\n      viewerHeight = value.viewerHeight;\n  var scaleX = viewerWidth / selectionWidth;\n  var scaleY = viewerHeight / selectionHeight;\n  var scaleLevel = Math.min(scaleX, scaleY);\n  var matrix = transform(scale(scaleLevel, scaleLevel), //2\n  translate(-selectionSVGPointX, -selectionSVGPointY) //1\n  );\n\n  if (isZoomLevelGoingOutOfBounds(value, scaleLevel / value.d)) {\n    // Do not allow scale and translation\n    return set(value, {\n      mode: MODE_IDLE,\n      startX: null,\n      startY: null,\n      endX: null,\n      endY: null\n    });\n  }\n\n  return set(value, _objectSpread(_objectSpread({\n    mode: MODE_IDLE\n  }, limitZoomLevel(value, matrix)), {}, {\n    startX: null,\n    startY: null,\n    endX: null,\n    endY: null\n  }), ACTION_ZOOM);\n}\nexport function fitToViewer(value) {\n  var SVGAlignX = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ALIGN_LEFT;\n  var SVGAlignY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ALIGN_TOP;\n  var viewerWidth = value.viewerWidth,\n      viewerHeight = value.viewerHeight,\n      SVGMinX = value.SVGMinX,\n      SVGMinY = value.SVGMinY,\n      SVGWidth = value.SVGWidth,\n      SVGHeight = value.SVGHeight;\n  var scaleX = viewerWidth / SVGWidth;\n  var scaleY = viewerHeight / SVGHeight;\n  var scaleLevel = Math.min(scaleX, scaleY);\n  var scaleMatrix = scale(scaleLevel, scaleLevel);\n  var translateX = -SVGMinX * scaleX;\n  var translateY = -SVGMinY * scaleY; // after fitting, SVG and the viewer will match in width (1) or in height (2) or SVG will cover the container with preserving aspect ratio (0)\n\n  if (scaleX < scaleY) {\n    var remainderY = viewerHeight - scaleX * SVGHeight; //(1) match in width, meaning scaled SVGHeight <= viewerHeight\n\n    switch (SVGAlignY) {\n      case ALIGN_TOP:\n        translateY = -SVGMinY * scaleLevel;\n        break;\n\n      case ALIGN_CENTER:\n        translateY = Math.round(remainderY / 2) - SVGMinY * scaleLevel;\n        break;\n\n      case ALIGN_BOTTOM:\n        translateY = remainderY - SVGMinY * scaleLevel;\n        break;\n\n      case ALIGN_COVER:\n        scaleMatrix = scale(scaleY, scaleY); // (0) we must now match to short edge, in this case - height\n\n        var remainderX = viewerWidth - scaleY * SVGWidth; // calculate remainder in the other scale\n\n        translateX = SVGMinX + Math.round(remainderX / 2); // center by the long edge\n\n        break;\n\n      default: //no op\n\n    }\n  } else {\n    var _remainderX = viewerWidth - scaleY * SVGWidth; //(2) match in height, meaning scaled SVGWidth <= viewerWidth\n\n\n    switch (SVGAlignX) {\n      case ALIGN_LEFT:\n        translateX = -SVGMinX * scaleLevel;\n        break;\n\n      case ALIGN_CENTER:\n        translateX = Math.round(_remainderX / 2) - SVGMinX * scaleLevel;\n        break;\n\n      case ALIGN_RIGHT:\n        translateX = _remainderX - SVGMinX * scaleLevel;\n        break;\n\n      case ALIGN_COVER:\n        scaleMatrix = scale(scaleX, scaleX); // (0) we must now match to short edge, in this case - width\n\n        var _remainderY = viewerHeight - scaleX * SVGHeight; // calculate remainder in the other scale\n\n\n        translateY = SVGMinY + Math.round(_remainderY / 2); // center by the long edge\n\n        break;\n\n      default: //no op\n\n    }\n  }\n\n  var translationMatrix = translate(translateX, translateY);\n  var matrix = transform(translationMatrix, //2\n  scaleMatrix //1\n  );\n\n  if (isZoomLevelGoingOutOfBounds(value, scaleLevel / value.d)) {\n    // Do not allow scale and translation\n    return set(value, {\n      mode: MODE_IDLE,\n      startX: null,\n      startY: null,\n      endX: null,\n      endY: null\n    });\n  }\n\n  return set(value, _objectSpread(_objectSpread({\n    mode: MODE_IDLE\n  }, limitZoomLevel(value, matrix)), {}, {\n    startX: null,\n    startY: null,\n    endX: null,\n    endY: null\n  }), ACTION_ZOOM);\n}\nexport function zoomOnViewerCenter(value, scaleFactor) {\n  var viewerWidth = value.viewerWidth,\n      viewerHeight = value.viewerHeight;\n  var SVGPoint = getSVGPoint(value, viewerWidth / 2, viewerHeight / 2);\n  return zoom(value, SVGPoint.x, SVGPoint.y, scaleFactor);\n}\nexport function startZooming(value, viewerX, viewerY) {\n  return set(value, {\n    mode: MODE_ZOOMING,\n    startX: viewerX,\n    startY: viewerY,\n    endX: viewerX,\n    endY: viewerY\n  });\n}\nexport function updateZooming(value, viewerX, viewerY) {\n  if (value.mode !== MODE_ZOOMING) throw new Error('update selection not allowed in this mode ' + value.mode);\n  return set(value, {\n    endX: viewerX,\n    endY: viewerY\n  });\n}\nexport function stopZooming(value, viewerX, viewerY, scaleFactor) {\n  var TOLERATED_DISTANCE = 7; //minimum distance to choose if area selection or drill down on point\n\n  var startX = value.startX,\n      startY = value.startY;\n  var start = getSVGPoint(value, startX, startY);\n  var end = getSVGPoint(value, viewerX, viewerY);\n\n  if (Math.abs(startX - viewerX) > TOLERATED_DISTANCE && Math.abs(startY - viewerY) > TOLERATED_DISTANCE) {\n    var box = calculateBox(start, end);\n    return fitSelection(value, box.x, box.y, box.width, box.height);\n  } else {\n    var SVGPoint = getSVGPoint(value, viewerX, viewerY);\n    return zoom(value, SVGPoint.x, SVGPoint.y, scaleFactor);\n  }\n}","map":{"version":3,"sources":["/home/jun/foodbank/node_modules/react-svg-pan-zoom/build-es/features/zoom.js"],"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","fromObject","scale","transform","translate","ACTION_ZOOM","MODE_IDLE","MODE_ZOOMING","ALIGN_CENTER","ALIGN_LEFT","ALIGN_RIGHT","ALIGN_TOP","ALIGN_BOTTOM","ALIGN_COVER","decompose","getSVGPoint","set","calculateBox","isZoomLevelGoingOutOfBounds","scaleFactor","_decompose","curScaleFactor","lessThanScaleFactorMin","scaleFactorMin","moreThanScaleFactorMax","scaleFactorMax","limitZoomLevel","matrix","scaleLevel","a","Math","max","min","d","zoom","SVGPointX","SVGPointY","mode","startX","startY","endX","endY","fitSelection","selectionSVGPointX","selectionSVGPointY","selectionWidth","selectionHeight","viewerWidth","viewerHeight","scaleX","scaleY","fitToViewer","SVGAlignX","undefined","SVGAlignY","SVGMinX","SVGMinY","SVGWidth","SVGHeight","scaleMatrix","translateX","translateY","remainderY","round","remainderX","_remainderX","_remainderY","translationMatrix","zoomOnViewerCenter","SVGPoint","x","y","startZooming","viewerX","viewerY","updateZooming","Error","stopZooming","TOLERATED_DISTANCE","start","end","abs","box","width","height"],"mappings":"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","sourcesContent":["function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { fromObject, scale, transform, translate } from 'transformation-matrix';\nimport { ACTION_ZOOM, MODE_IDLE, MODE_ZOOMING, ALIGN_CENTER, ALIGN_LEFT, ALIGN_RIGHT, ALIGN_TOP, ALIGN_BOTTOM, ALIGN_COVER } from '../constants';\nimport { decompose, getSVGPoint, set } from './common';\nimport calculateBox from '../utils/calculateBox';\nexport function isZoomLevelGoingOutOfBounds(value, scaleFactor) {\n  var _decompose = decompose(value),\n      curScaleFactor = _decompose.scaleFactor;\n\n  var lessThanScaleFactorMin = value.scaleFactorMin && curScaleFactor * scaleFactor < value.scaleFactorMin;\n  var moreThanScaleFactorMax = value.scaleFactorMax && curScaleFactor * scaleFactor > value.scaleFactorMax;\n  return lessThanScaleFactorMin && scaleFactor < 1 || moreThanScaleFactorMax && scaleFactor > 1;\n}\nexport function limitZoomLevel(value, matrix) {\n  var scaleLevel = matrix.a;\n\n  if (value.scaleFactorMin != null) {\n    // limit minimum zoom\n    scaleLevel = Math.max(scaleLevel, value.scaleFactorMin);\n  }\n\n  if (value.scaleFactorMax != null) {\n    // limit maximum zoom\n    scaleLevel = Math.min(scaleLevel, value.scaleFactorMax);\n  }\n\n  return set(matrix, {\n    a: scaleLevel,\n    d: scaleLevel\n  });\n}\nexport function zoom(value, SVGPointX, SVGPointY, scaleFactor) {\n  if (isZoomLevelGoingOutOfBounds(value, scaleFactor)) {\n    // Do not change translation and scale of value\n    return value;\n  }\n\n  var matrix = transform(fromObject(value), translate(SVGPointX, SVGPointY), scale(scaleFactor, scaleFactor), translate(-SVGPointX, -SVGPointY));\n  return set(value, _objectSpread(_objectSpread({\n    mode: MODE_IDLE\n  }, matrix), {}, {\n    startX: null,\n    startY: null,\n    endX: null,\n    endY: null\n  }), ACTION_ZOOM);\n} //ENHANCEMENT: add ability to control alignment\n//ENHANCEMENT: add ability to selectively fit image inside viewer\n//ENHANCEMENT: refactor some logic in order to merge with fitToViewer function\n\nexport function fitSelection(value, selectionSVGPointX, selectionSVGPointY, selectionWidth, selectionHeight) {\n  var viewerWidth = value.viewerWidth,\n      viewerHeight = value.viewerHeight;\n  var scaleX = viewerWidth / selectionWidth;\n  var scaleY = viewerHeight / selectionHeight;\n  var scaleLevel = Math.min(scaleX, scaleY);\n  var matrix = transform(scale(scaleLevel, scaleLevel), //2\n  translate(-selectionSVGPointX, -selectionSVGPointY) //1\n  );\n\n  if (isZoomLevelGoingOutOfBounds(value, scaleLevel / value.d)) {\n    // Do not allow scale and translation\n    return set(value, {\n      mode: MODE_IDLE,\n      startX: null,\n      startY: null,\n      endX: null,\n      endY: null\n    });\n  }\n\n  return set(value, _objectSpread(_objectSpread({\n    mode: MODE_IDLE\n  }, limitZoomLevel(value, matrix)), {}, {\n    startX: null,\n    startY: null,\n    endX: null,\n    endY: null\n  }), ACTION_ZOOM);\n}\nexport function fitToViewer(value) {\n  var SVGAlignX = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ALIGN_LEFT;\n  var SVGAlignY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ALIGN_TOP;\n  var viewerWidth = value.viewerWidth,\n      viewerHeight = value.viewerHeight,\n      SVGMinX = value.SVGMinX,\n      SVGMinY = value.SVGMinY,\n      SVGWidth = value.SVGWidth,\n      SVGHeight = value.SVGHeight;\n  var scaleX = viewerWidth / SVGWidth;\n  var scaleY = viewerHeight / SVGHeight;\n  var scaleLevel = Math.min(scaleX, scaleY);\n  var scaleMatrix = scale(scaleLevel, scaleLevel);\n  var translateX = -SVGMinX * scaleX;\n  var translateY = -SVGMinY * scaleY; // after fitting, SVG and the viewer will match in width (1) or in height (2) or SVG will cover the container with preserving aspect ratio (0)\n\n  if (scaleX < scaleY) {\n    var remainderY = viewerHeight - scaleX * SVGHeight; //(1) match in width, meaning scaled SVGHeight <= viewerHeight\n\n    switch (SVGAlignY) {\n      case ALIGN_TOP:\n        translateY = -SVGMinY * scaleLevel;\n        break;\n\n      case ALIGN_CENTER:\n        translateY = Math.round(remainderY / 2) - SVGMinY * scaleLevel;\n        break;\n\n      case ALIGN_BOTTOM:\n        translateY = remainderY - SVGMinY * scaleLevel;\n        break;\n\n      case ALIGN_COVER:\n        scaleMatrix = scale(scaleY, scaleY); // (0) we must now match to short edge, in this case - height\n\n        var remainderX = viewerWidth - scaleY * SVGWidth; // calculate remainder in the other scale\n\n        translateX = SVGMinX + Math.round(remainderX / 2); // center by the long edge\n\n        break;\n\n      default: //no op\n\n    }\n  } else {\n    var _remainderX = viewerWidth - scaleY * SVGWidth; //(2) match in height, meaning scaled SVGWidth <= viewerWidth\n\n\n    switch (SVGAlignX) {\n      case ALIGN_LEFT:\n        translateX = -SVGMinX * scaleLevel;\n        break;\n\n      case ALIGN_CENTER:\n        translateX = Math.round(_remainderX / 2) - SVGMinX * scaleLevel;\n        break;\n\n      case ALIGN_RIGHT:\n        translateX = _remainderX - SVGMinX * scaleLevel;\n        break;\n\n      case ALIGN_COVER:\n        scaleMatrix = scale(scaleX, scaleX); // (0) we must now match to short edge, in this case - width\n\n        var _remainderY = viewerHeight - scaleX * SVGHeight; // calculate remainder in the other scale\n\n\n        translateY = SVGMinY + Math.round(_remainderY / 2); // center by the long edge\n\n        break;\n\n      default: //no op\n\n    }\n  }\n\n  var translationMatrix = translate(translateX, translateY);\n  var matrix = transform(translationMatrix, //2\n  scaleMatrix //1\n  );\n\n  if (isZoomLevelGoingOutOfBounds(value, scaleLevel / value.d)) {\n    // Do not allow scale and translation\n    return set(value, {\n      mode: MODE_IDLE,\n      startX: null,\n      startY: null,\n      endX: null,\n      endY: null\n    });\n  }\n\n  return set(value, _objectSpread(_objectSpread({\n    mode: MODE_IDLE\n  }, limitZoomLevel(value, matrix)), {}, {\n    startX: null,\n    startY: null,\n    endX: null,\n    endY: null\n  }), ACTION_ZOOM);\n}\nexport function zoomOnViewerCenter(value, scaleFactor) {\n  var viewerWidth = value.viewerWidth,\n      viewerHeight = value.viewerHeight;\n  var SVGPoint = getSVGPoint(value, viewerWidth / 2, viewerHeight / 2);\n  return zoom(value, SVGPoint.x, SVGPoint.y, scaleFactor);\n}\nexport function startZooming(value, viewerX, viewerY) {\n  return set(value, {\n    mode: MODE_ZOOMING,\n    startX: viewerX,\n    startY: viewerY,\n    endX: viewerX,\n    endY: viewerY\n  });\n}\nexport function updateZooming(value, viewerX, viewerY) {\n  if (value.mode !== MODE_ZOOMING) throw new Error('update selection not allowed in this mode ' + value.mode);\n  return set(value, {\n    endX: viewerX,\n    endY: viewerY\n  });\n}\nexport function stopZooming(value, viewerX, viewerY, scaleFactor) {\n  var TOLERATED_DISTANCE = 7; //minimum distance to choose if area selection or drill down on point\n\n  var startX = value.startX,\n      startY = value.startY;\n  var start = getSVGPoint(value, startX, startY);\n  var end = getSVGPoint(value, viewerX, viewerY);\n\n  if (Math.abs(startX - viewerX) > TOLERATED_DISTANCE && Math.abs(startY - viewerY) > TOLERATED_DISTANCE) {\n    var box = calculateBox(start, end);\n    return fitSelection(value, box.x, box.y, box.width, box.height);\n  } else {\n    var SVGPoint = getSVGPoint(value, viewerX, viewerY);\n    return zoom(value, SVGPoint.x, SVGPoint.y, scaleFactor);\n  }\n}"]},"metadata":{},"sourceType":"module"}