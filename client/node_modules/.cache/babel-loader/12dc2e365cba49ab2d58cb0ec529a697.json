{"ast":null,"code":"import { forEach } from 'property-expr';\n\nlet trim = part => part.substr(0, part.length - 1).substr(1);\n\nexport function getIn(schema, path, value, context = value) {\n  let parent, lastPart, lastPartDebug; // root path: ''\n\n  if (!path) return {\n    parent,\n    parentPath: path,\n    schema\n  };\n  forEach(path, (_part, isBracket, isArray) => {\n    let part = isBracket ? trim(_part) : _part;\n    schema = schema.resolve({\n      context,\n      parent,\n      value\n    });\n\n    if (schema.innerType) {\n      let idx = isArray ? parseInt(part, 10) : 0;\n\n      if (value && idx >= value.length) {\n        throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path}. ` + `because there is no value at that index. `);\n      }\n\n      parent = value;\n      value = value && value[idx];\n      schema = schema.innerType;\n    } // sometimes the array index part of a path doesn't exist: \"nested.arr.child\"\n    // in these cases the current part is the next schema and should be processed\n    // in this iteration. For cases where the index signature is included this\n    // check will fail and we'll handle the `child` part on the next iteration like normal\n\n\n    if (!isArray) {\n      if (!schema.fields || !schema.fields[part]) throw new Error(`The schema does not contain the path: ${path}. ` + `(failed at: ${lastPartDebug} which is a type: \"${schema._type}\")`);\n      parent = value;\n      value = value && value[part];\n      schema = schema.fields[part];\n    }\n\n    lastPart = part;\n    lastPartDebug = isBracket ? '[' + _part + ']' : '.' + _part;\n  });\n  return {\n    schema,\n    parent,\n    parentPath: lastPart\n  };\n}\n\nconst reach = (obj, path, value, context) => getIn(obj, path, value, context).schema;\n\nexport default reach;","map":{"version":3,"sources":["/home/jun/foodbank/node_modules/yup/es/util/reach.js"],"names":["forEach","trim","part","substr","length","getIn","schema","path","value","context","parent","lastPart","lastPartDebug","parentPath","_part","isBracket","isArray","resolve","innerType","idx","parseInt","Error","fields","_type","reach","obj"],"mappings":"AAAA,SAASA,OAAT,QAAwB,eAAxB;;AAEA,IAAIC,IAAI,GAAGC,IAAI,IAAIA,IAAI,CAACC,MAAL,CAAY,CAAZ,EAAeD,IAAI,CAACE,MAAL,GAAc,CAA7B,EAAgCD,MAAhC,CAAuC,CAAvC,CAAnB;;AAEA,OAAO,SAASE,KAAT,CAAeC,MAAf,EAAuBC,IAAvB,EAA6BC,KAA7B,EAAoCC,OAAO,GAAGD,KAA9C,EAAqD;AAC1D,MAAIE,MAAJ,EAAYC,QAAZ,EAAsBC,aAAtB,CAD0D,CACrB;;AAErC,MAAI,CAACL,IAAL,EAAW,OAAO;AAChBG,IAAAA,MADgB;AAEhBG,IAAAA,UAAU,EAAEN,IAFI;AAGhBD,IAAAA;AAHgB,GAAP;AAKXN,EAAAA,OAAO,CAACO,IAAD,EAAO,CAACO,KAAD,EAAQC,SAAR,EAAmBC,OAAnB,KAA+B;AAC3C,QAAId,IAAI,GAAGa,SAAS,GAAGd,IAAI,CAACa,KAAD,CAAP,GAAiBA,KAArC;AACAR,IAAAA,MAAM,GAAGA,MAAM,CAACW,OAAP,CAAe;AACtBR,MAAAA,OADsB;AAEtBC,MAAAA,MAFsB;AAGtBF,MAAAA;AAHsB,KAAf,CAAT;;AAMA,QAAIF,MAAM,CAACY,SAAX,EAAsB;AACpB,UAAIC,GAAG,GAAGH,OAAO,GAAGI,QAAQ,CAAClB,IAAD,EAAO,EAAP,CAAX,GAAwB,CAAzC;;AAEA,UAAIM,KAAK,IAAIW,GAAG,IAAIX,KAAK,CAACJ,MAA1B,EAAkC;AAChC,cAAM,IAAIiB,KAAJ,CAAW,oDAAmDP,KAAM,kBAAiBP,IAAK,IAAhF,GAAuF,2CAAjG,CAAN;AACD;;AAEDG,MAAAA,MAAM,GAAGF,KAAT;AACAA,MAAAA,KAAK,GAAGA,KAAK,IAAIA,KAAK,CAACW,GAAD,CAAtB;AACAb,MAAAA,MAAM,GAAGA,MAAM,CAACY,SAAhB;AACD,KAlB0C,CAkBzC;AACF;AACA;AACA;;;AAGA,QAAI,CAACF,OAAL,EAAc;AACZ,UAAI,CAACV,MAAM,CAACgB,MAAR,IAAkB,CAAChB,MAAM,CAACgB,MAAP,CAAcpB,IAAd,CAAvB,EAA4C,MAAM,IAAImB,KAAJ,CAAW,yCAAwCd,IAAK,IAA9C,GAAqD,eAAcK,aAAc,sBAAqBN,MAAM,CAACiB,KAAM,IAA7H,CAAN;AAC5Cb,MAAAA,MAAM,GAAGF,KAAT;AACAA,MAAAA,KAAK,GAAGA,KAAK,IAAIA,KAAK,CAACN,IAAD,CAAtB;AACAI,MAAAA,MAAM,GAAGA,MAAM,CAACgB,MAAP,CAAcpB,IAAd,CAAT;AACD;;AAEDS,IAAAA,QAAQ,GAAGT,IAAX;AACAU,IAAAA,aAAa,GAAGG,SAAS,GAAG,MAAMD,KAAN,GAAc,GAAjB,GAAuB,MAAMA,KAAtD;AACD,GAjCM,CAAP;AAkCA,SAAO;AACLR,IAAAA,MADK;AAELI,IAAAA,MAFK;AAGLG,IAAAA,UAAU,EAAEF;AAHP,GAAP;AAKD;;AAED,MAAMa,KAAK,GAAG,CAACC,GAAD,EAAMlB,IAAN,EAAYC,KAAZ,EAAmBC,OAAnB,KAA+BJ,KAAK,CAACoB,GAAD,EAAMlB,IAAN,EAAYC,KAAZ,EAAmBC,OAAnB,CAAL,CAAiCH,MAA9E;;AAEA,eAAekB,KAAf","sourcesContent":["import { forEach } from 'property-expr';\n\nlet trim = part => part.substr(0, part.length - 1).substr(1);\n\nexport function getIn(schema, path, value, context = value) {\n  let parent, lastPart, lastPartDebug; // root path: ''\n\n  if (!path) return {\n    parent,\n    parentPath: path,\n    schema\n  };\n  forEach(path, (_part, isBracket, isArray) => {\n    let part = isBracket ? trim(_part) : _part;\n    schema = schema.resolve({\n      context,\n      parent,\n      value\n    });\n\n    if (schema.innerType) {\n      let idx = isArray ? parseInt(part, 10) : 0;\n\n      if (value && idx >= value.length) {\n        throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path}. ` + `because there is no value at that index. `);\n      }\n\n      parent = value;\n      value = value && value[idx];\n      schema = schema.innerType;\n    } // sometimes the array index part of a path doesn't exist: \"nested.arr.child\"\n    // in these cases the current part is the next schema and should be processed\n    // in this iteration. For cases where the index signature is included this\n    // check will fail and we'll handle the `child` part on the next iteration like normal\n\n\n    if (!isArray) {\n      if (!schema.fields || !schema.fields[part]) throw new Error(`The schema does not contain the path: ${path}. ` + `(failed at: ${lastPartDebug} which is a type: \"${schema._type}\")`);\n      parent = value;\n      value = value && value[part];\n      schema = schema.fields[part];\n    }\n\n    lastPart = part;\n    lastPartDebug = isBracket ? '[' + _part + ']' : '.' + _part;\n  });\n  return {\n    schema,\n    parent,\n    parentPath: lastPart\n  };\n}\n\nconst reach = (obj, path, value, context) => getIn(obj, path, value, context).schema;\n\nexport default reach;"]},"metadata":{},"sourceType":"module"}