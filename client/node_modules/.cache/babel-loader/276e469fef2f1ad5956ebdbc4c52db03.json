{"ast":null,"code":"/**\n * Calculate a point transformed with an affine matrix\n * @param matrix {Matrix} Affine Matrix\n * @param  point {Point} Point\n * @returns {Point} Point\n */\nexport function applyToPoint(matrix, point) {\n  return Array.isArray(point) ? [matrix.a * point[0] + matrix.c * point[1] + matrix.e, matrix.b * point[0] + matrix.d * point[1] + matrix.f] : {\n    x: matrix.a * point.x + matrix.c * point.y + matrix.e,\n    y: matrix.b * point.x + matrix.d * point.y + matrix.f\n  };\n}\n/**\n * Calculate an array of points transformed with an affine matrix\n * @param matrix {Matrix} Affine Matrix\n * @param points {Point[]} Array of point\n * @returns {Point[]} Array of point\n */\n\nexport function applyToPoints(matrix, points) {\n  return points.map(point => applyToPoint(matrix, point));\n}","map":{"version":3,"sources":["/home/jun/foodbank/node_modules/transformation-matrix/src/applyToPoint.js"],"names":["applyToPoint","matrix","point","Array","isArray","a","c","e","b","d","f","x","y","applyToPoints","points","map"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,YAAT,CAAuBC,MAAvB,EAA+BC,KAA/B,EAAsC;AAC3C,SAAOC,KAAK,CAACC,OAAN,CAAcF,KAAd,IACH,CACED,MAAM,CAACI,CAAP,GAAWH,KAAK,CAAC,CAAD,CAAhB,GAAsBD,MAAM,CAACK,CAAP,GAAWJ,KAAK,CAAC,CAAD,CAAtC,GAA4CD,MAAM,CAACM,CADrD,EAEEN,MAAM,CAACO,CAAP,GAAWN,KAAK,CAAC,CAAD,CAAhB,GAAsBD,MAAM,CAACQ,CAAP,GAAWP,KAAK,CAAC,CAAD,CAAtC,GAA4CD,MAAM,CAACS,CAFrD,CADG,GAKH;AACEC,IAAAA,CAAC,EAAEV,MAAM,CAACI,CAAP,GAAWH,KAAK,CAACS,CAAjB,GAAqBV,MAAM,CAACK,CAAP,GAAWJ,KAAK,CAACU,CAAtC,GAA0CX,MAAM,CAACM,CADtD;AAEEK,IAAAA,CAAC,EAAEX,MAAM,CAACO,CAAP,GAAWN,KAAK,CAACS,CAAjB,GAAqBV,MAAM,CAACQ,CAAP,GAAWP,KAAK,CAACU,CAAtC,GAA0CX,MAAM,CAACS;AAFtD,GALJ;AASD;AAED;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASG,aAAT,CAAwBZ,MAAxB,EAAgCa,MAAhC,EAAwC;AAC7C,SAAOA,MAAM,CAACC,GAAP,CAAWb,KAAK,IAAIF,YAAY,CAACC,MAAD,EAASC,KAAT,CAAhC,CAAP;AACD","sourcesContent":["/**\n * Calculate a point transformed with an affine matrix\n * @param matrix {Matrix} Affine Matrix\n * @param  point {Point} Point\n * @returns {Point} Point\n */\nexport function applyToPoint (matrix, point) {\n  return Array.isArray(point)\n    ? [\n        matrix.a * point[0] + matrix.c * point[1] + matrix.e,\n        matrix.b * point[0] + matrix.d * point[1] + matrix.f\n      ]\n    : {\n        x: matrix.a * point.x + matrix.c * point.y + matrix.e,\n        y: matrix.b * point.x + matrix.d * point.y + matrix.f\n      }\n}\n\n/**\n * Calculate an array of points transformed with an affine matrix\n * @param matrix {Matrix} Affine Matrix\n * @param points {Point[]} Array of point\n * @returns {Point[]} Array of point\n */\nexport function applyToPoints (matrix, points) {\n  return points.map(point => applyToPoint(matrix, point))\n}\n"]},"metadata":{},"sourceType":"module"}