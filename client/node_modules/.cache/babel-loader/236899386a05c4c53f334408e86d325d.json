{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nimport has from 'lodash/has';\nimport snakeCase from 'lodash/snakeCase';\nimport camelCase from 'lodash/camelCase';\nimport mapKeys from 'lodash/mapKeys';\nimport mapValues from 'lodash/mapValues';\nimport { getter } from 'property-expr';\nimport { object as locale } from './locale';\nimport sortFields from './util/sortFields';\nimport sortByKeyOrder from './util/sortByKeyOrder';\nimport runTests from './util/runTests';\nimport ValidationError from './ValidationError';\nimport BaseSchema from './schema';\n\nlet isObject = obj => Object.prototype.toString.call(obj) === '[object Object]';\n\nfunction unknown(ctx, value) {\n  let known = Object.keys(ctx.fields);\n  return Object.keys(value).filter(key => known.indexOf(key) === -1);\n}\n\nconst defaultSort = sortByKeyOrder([]);\nexport default class ObjectSchema extends BaseSchema {\n  constructor(spec) {\n    super({\n      type: 'object'\n    });\n    this.fields = Object.create(null);\n    this._sortErrors = defaultSort;\n    this._nodes = [];\n    this._excludedEdges = [];\n    this.withMutation(() => {\n      this.transform(function coerce(value) {\n        if (typeof value === 'string') {\n          try {\n            value = JSON.parse(value);\n          } catch (err) {\n            value = null;\n          }\n        }\n\n        if (this.isType(value)) return value;\n        return null;\n      });\n\n      if (spec) {\n        this.shape(spec);\n      }\n    });\n  }\n\n  _typeCheck(value) {\n    return isObject(value) || typeof value === 'function';\n  }\n\n  _cast(_value, options = {}) {\n    var _options$stripUnknown;\n\n    let value = super._cast(_value, options); //should ignore nulls here\n\n\n    if (value === undefined) return this.getDefault();\n    if (!this._typeCheck(value)) return value;\n    let fields = this.fields;\n    let strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;\n\n    let props = this._nodes.concat(Object.keys(value).filter(v => this._nodes.indexOf(v) === -1));\n\n    let intermediateValue = {}; // is filled during the transform below\n\n    let innerOptions = _extends({}, options, {\n      parent: intermediateValue,\n      __validating: options.__validating || false\n    });\n\n    let isChanged = false;\n\n    for (const prop of props) {\n      let field = fields[prop];\n      let exists = has(value, prop);\n\n      if (field) {\n        let fieldValue;\n        let inputValue = value[prop]; // safe to mutate since this is fired in sequence\n\n        innerOptions.path = (options.path ? `${options.path}.` : '') + prop; // innerOptions.value = value[prop];\n\n        field = field.resolve({\n          value: inputValue,\n          context: options.context,\n          parent: intermediateValue\n        });\n        let fieldSpec = 'spec' in field ? field.spec : undefined;\n        let strict = fieldSpec == null ? void 0 : fieldSpec.strict;\n\n        if (fieldSpec == null ? void 0 : fieldSpec.strip) {\n          isChanged = isChanged || prop in value;\n          continue;\n        }\n\n        fieldValue = !options.__validating || !strict ? // TODO: use _cast, this is double resolving\n        field.cast(value[prop], innerOptions) : value[prop];\n\n        if (fieldValue !== undefined) {\n          intermediateValue[prop] = fieldValue;\n        }\n      } else if (exists && !strip) {\n        intermediateValue[prop] = value[prop];\n      }\n\n      if (intermediateValue[prop] !== value[prop]) {\n        isChanged = true;\n      }\n    }\n\n    return isChanged ? intermediateValue : value;\n  }\n\n  _validate(_value, opts = {}, callback) {\n    let errors = [];\n    let {\n      sync,\n      from = [],\n      originalValue = _value,\n      abortEarly = this.spec.abortEarly,\n      recursive = this.spec.recursive\n    } = opts;\n    from = [{\n      schema: this,\n      value: originalValue\n    }, ...from]; // this flag is needed for handling `strict` correctly in the context of\n    // validation vs just casting. e.g strict() on a field is only used when validating\n\n    opts.__validating = true;\n    opts.originalValue = originalValue;\n    opts.from = from;\n\n    super._validate(_value, opts, (err, value) => {\n      if (err) {\n        if (!ValidationError.isError(err) || abortEarly) {\n          return void callback(err, value);\n        }\n\n        errors.push(err);\n      }\n\n      if (!recursive || !isObject(value)) {\n        callback(errors[0] || null, value);\n        return;\n      }\n\n      originalValue = originalValue || value;\n\n      let tests = this._nodes.map(key => (_, cb) => {\n        let path = key.indexOf('.') === -1 ? (opts.path ? `${opts.path}.` : '') + key : `${opts.path || ''}[\"${key}\"]`;\n        let field = this.fields[key];\n\n        if (field && 'validate' in field) {\n          field.validate(value[key], _extends({}, opts, {\n            // @ts-ignore\n            path,\n            from,\n            // inner fields are always strict:\n            // 1. this isn't strict so the casting will also have cast inner values\n            // 2. this is strict in which case the nested values weren't cast either\n            strict: true,\n            parent: value,\n            originalValue: originalValue[key]\n          }), cb);\n          return;\n        }\n\n        cb(null);\n      });\n\n      runTests({\n        sync,\n        tests,\n        value,\n        errors,\n        endEarly: abortEarly,\n        sort: this._sortErrors,\n        path: opts.path\n      }, callback);\n    });\n  }\n\n  clone(spec) {\n    const next = super.clone(spec);\n    next.fields = _extends({}, this.fields);\n    next._nodes = this._nodes;\n    next._excludedEdges = this._excludedEdges;\n    next._sortErrors = this._sortErrors;\n    return next;\n  }\n\n  concat(schema) {\n    let next = super.concat(schema);\n    let nextFields = next.fields;\n\n    for (let [field, schemaOrRef] of Object.entries(this.fields)) {\n      const target = nextFields[field];\n\n      if (target === undefined) {\n        nextFields[field] = schemaOrRef;\n      } else if (target instanceof BaseSchema && schemaOrRef instanceof BaseSchema) {\n        nextFields[field] = schemaOrRef.concat(target);\n      }\n    }\n\n    return next.withMutation(next => next.shape(nextFields));\n  }\n\n  getDefaultFromShape() {\n    let dft = {};\n\n    this._nodes.forEach(key => {\n      const field = this.fields[key];\n      dft[key] = 'default' in field ? field.getDefault() : undefined;\n    });\n\n    return dft;\n  }\n\n  _getDefault() {\n    if ('default' in this.spec) {\n      return super._getDefault();\n    } // if there is no default set invent one\n\n\n    if (!this._nodes.length) {\n      return undefined;\n    }\n\n    return this.getDefaultFromShape();\n  }\n\n  shape(additions, excludes = []) {\n    let next = this.clone();\n    let fields = Object.assign(next.fields, additions);\n    next.fields = fields;\n    next._sortErrors = sortByKeyOrder(Object.keys(fields));\n\n    if (excludes.length) {\n      if (!Array.isArray(excludes[0])) excludes = [excludes];\n      let keys = excludes.map(([first, second]) => `${first}-${second}`);\n      next._excludedEdges = next._excludedEdges.concat(keys);\n    }\n\n    next._nodes = sortFields(fields, next._excludedEdges);\n    return next;\n  }\n\n  pick(keys) {\n    const picked = {};\n\n    for (const key of keys) {\n      if (this.fields[key]) picked[key] = this.fields[key];\n    }\n\n    return this.clone().withMutation(next => {\n      next.fields = {};\n      return next.shape(picked);\n    });\n  }\n\n  omit(keys) {\n    const next = this.clone();\n    const fields = next.fields;\n    next.fields = {};\n\n    for (const key of keys) {\n      delete fields[key];\n    }\n\n    return next.withMutation(next => next.shape(fields));\n  }\n\n  from(from, to, alias) {\n    let fromGetter = getter(from, true);\n    return this.transform(obj => {\n      if (obj == null) return obj;\n      let newObj = obj;\n\n      if (has(obj, from)) {\n        newObj = _extends({}, obj);\n        if (!alias) delete newObj[from];\n        newObj[to] = fromGetter(obj);\n      }\n\n      return newObj;\n    });\n  }\n\n  noUnknown(noAllow = true, message = locale.noUnknown) {\n    if (typeof noAllow === 'string') {\n      message = noAllow;\n      noAllow = true;\n    }\n\n    let next = this.test({\n      name: 'noUnknown',\n      exclusive: true,\n      message: message,\n\n      test(value) {\n        if (value == null) return true;\n        const unknownKeys = unknown(this.schema, value);\n        return !noAllow || unknownKeys.length === 0 || this.createError({\n          params: {\n            unknown: unknownKeys.join(', ')\n          }\n        });\n      }\n\n    });\n    next.spec.noUnknown = noAllow;\n    return next;\n  }\n\n  unknown(allow = true, message = locale.noUnknown) {\n    return this.noUnknown(!allow, message);\n  }\n\n  transformKeys(fn) {\n    return this.transform(obj => obj && mapKeys(obj, (_, key) => fn(key)));\n  }\n\n  camelCase() {\n    return this.transformKeys(camelCase);\n  }\n\n  snakeCase() {\n    return this.transformKeys(snakeCase);\n  }\n\n  constantCase() {\n    return this.transformKeys(key => snakeCase(key).toUpperCase());\n  }\n\n  describe() {\n    let base = super.describe();\n    base.fields = mapValues(this.fields, value => value.describe());\n    return base;\n  }\n\n}\nexport function create(spec) {\n  return new ObjectSchema(spec);\n}\ncreate.prototype = ObjectSchema.prototype;","map":{"version":3,"sources":["/home/jun/foodbank/node_modules/yup/es/object.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","has","snakeCase","camelCase","mapKeys","mapValues","getter","object","locale","sortFields","sortByKeyOrder","runTests","ValidationError","BaseSchema","isObject","obj","toString","unknown","ctx","value","known","keys","fields","filter","indexOf","defaultSort","ObjectSchema","constructor","spec","type","create","_sortErrors","_nodes","_excludedEdges","withMutation","transform","coerce","JSON","parse","err","isType","shape","_typeCheck","_cast","_value","options","_options$stripUnknown","undefined","getDefault","strip","stripUnknown","noUnknown","props","concat","v","intermediateValue","innerOptions","parent","__validating","isChanged","prop","field","exists","fieldValue","inputValue","path","resolve","context","fieldSpec","strict","cast","_validate","opts","callback","errors","sync","from","originalValue","abortEarly","recursive","schema","isError","push","tests","map","_","cb","validate","endEarly","sort","clone","next","nextFields","schemaOrRef","entries","getDefaultFromShape","dft","forEach","_getDefault","additions","excludes","Array","isArray","first","second","pick","picked","omit","to","alias","fromGetter","newObj","noAllow","message","test","name","exclusive","unknownKeys","createError","params","join","allow","transformKeys","fn","constantCase","toUpperCase","describe","base"],"mappings":"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","sourcesContent":["function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport has from 'lodash/has';\nimport snakeCase from 'lodash/snakeCase';\nimport camelCase from 'lodash/camelCase';\nimport mapKeys from 'lodash/mapKeys';\nimport mapValues from 'lodash/mapValues';\nimport { getter } from 'property-expr';\nimport { object as locale } from './locale';\nimport sortFields from './util/sortFields';\nimport sortByKeyOrder from './util/sortByKeyOrder';\nimport runTests from './util/runTests';\nimport ValidationError from './ValidationError';\nimport BaseSchema from './schema';\n\nlet isObject = obj => Object.prototype.toString.call(obj) === '[object Object]';\n\nfunction unknown(ctx, value) {\n  let known = Object.keys(ctx.fields);\n  return Object.keys(value).filter(key => known.indexOf(key) === -1);\n}\n\nconst defaultSort = sortByKeyOrder([]);\nexport default class ObjectSchema extends BaseSchema {\n  constructor(spec) {\n    super({\n      type: 'object'\n    });\n    this.fields = Object.create(null);\n    this._sortErrors = defaultSort;\n    this._nodes = [];\n    this._excludedEdges = [];\n    this.withMutation(() => {\n      this.transform(function coerce(value) {\n        if (typeof value === 'string') {\n          try {\n            value = JSON.parse(value);\n          } catch (err) {\n            value = null;\n          }\n        }\n\n        if (this.isType(value)) return value;\n        return null;\n      });\n\n      if (spec) {\n        this.shape(spec);\n      }\n    });\n  }\n\n  _typeCheck(value) {\n    return isObject(value) || typeof value === 'function';\n  }\n\n  _cast(_value, options = {}) {\n    var _options$stripUnknown;\n\n    let value = super._cast(_value, options); //should ignore nulls here\n\n\n    if (value === undefined) return this.getDefault();\n    if (!this._typeCheck(value)) return value;\n    let fields = this.fields;\n    let strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;\n\n    let props = this._nodes.concat(Object.keys(value).filter(v => this._nodes.indexOf(v) === -1));\n\n    let intermediateValue = {}; // is filled during the transform below\n\n    let innerOptions = _extends({}, options, {\n      parent: intermediateValue,\n      __validating: options.__validating || false\n    });\n\n    let isChanged = false;\n\n    for (const prop of props) {\n      let field = fields[prop];\n      let exists = has(value, prop);\n\n      if (field) {\n        let fieldValue;\n        let inputValue = value[prop]; // safe to mutate since this is fired in sequence\n\n        innerOptions.path = (options.path ? `${options.path}.` : '') + prop; // innerOptions.value = value[prop];\n\n        field = field.resolve({\n          value: inputValue,\n          context: options.context,\n          parent: intermediateValue\n        });\n        let fieldSpec = 'spec' in field ? field.spec : undefined;\n        let strict = fieldSpec == null ? void 0 : fieldSpec.strict;\n\n        if (fieldSpec == null ? void 0 : fieldSpec.strip) {\n          isChanged = isChanged || prop in value;\n          continue;\n        }\n\n        fieldValue = !options.__validating || !strict ? // TODO: use _cast, this is double resolving\n        field.cast(value[prop], innerOptions) : value[prop];\n\n        if (fieldValue !== undefined) {\n          intermediateValue[prop] = fieldValue;\n        }\n      } else if (exists && !strip) {\n        intermediateValue[prop] = value[prop];\n      }\n\n      if (intermediateValue[prop] !== value[prop]) {\n        isChanged = true;\n      }\n    }\n\n    return isChanged ? intermediateValue : value;\n  }\n\n  _validate(_value, opts = {}, callback) {\n    let errors = [];\n    let {\n      sync,\n      from = [],\n      originalValue = _value,\n      abortEarly = this.spec.abortEarly,\n      recursive = this.spec.recursive\n    } = opts;\n    from = [{\n      schema: this,\n      value: originalValue\n    }, ...from]; // this flag is needed for handling `strict` correctly in the context of\n    // validation vs just casting. e.g strict() on a field is only used when validating\n\n    opts.__validating = true;\n    opts.originalValue = originalValue;\n    opts.from = from;\n\n    super._validate(_value, opts, (err, value) => {\n      if (err) {\n        if (!ValidationError.isError(err) || abortEarly) {\n          return void callback(err, value);\n        }\n\n        errors.push(err);\n      }\n\n      if (!recursive || !isObject(value)) {\n        callback(errors[0] || null, value);\n        return;\n      }\n\n      originalValue = originalValue || value;\n\n      let tests = this._nodes.map(key => (_, cb) => {\n        let path = key.indexOf('.') === -1 ? (opts.path ? `${opts.path}.` : '') + key : `${opts.path || ''}[\"${key}\"]`;\n        let field = this.fields[key];\n\n        if (field && 'validate' in field) {\n          field.validate(value[key], _extends({}, opts, {\n            // @ts-ignore\n            path,\n            from,\n            // inner fields are always strict:\n            // 1. this isn't strict so the casting will also have cast inner values\n            // 2. this is strict in which case the nested values weren't cast either\n            strict: true,\n            parent: value,\n            originalValue: originalValue[key]\n          }), cb);\n          return;\n        }\n\n        cb(null);\n      });\n\n      runTests({\n        sync,\n        tests,\n        value,\n        errors,\n        endEarly: abortEarly,\n        sort: this._sortErrors,\n        path: opts.path\n      }, callback);\n    });\n  }\n\n  clone(spec) {\n    const next = super.clone(spec);\n    next.fields = _extends({}, this.fields);\n    next._nodes = this._nodes;\n    next._excludedEdges = this._excludedEdges;\n    next._sortErrors = this._sortErrors;\n    return next;\n  }\n\n  concat(schema) {\n    let next = super.concat(schema);\n    let nextFields = next.fields;\n\n    for (let [field, schemaOrRef] of Object.entries(this.fields)) {\n      const target = nextFields[field];\n\n      if (target === undefined) {\n        nextFields[field] = schemaOrRef;\n      } else if (target instanceof BaseSchema && schemaOrRef instanceof BaseSchema) {\n        nextFields[field] = schemaOrRef.concat(target);\n      }\n    }\n\n    return next.withMutation(next => next.shape(nextFields));\n  }\n\n  getDefaultFromShape() {\n    let dft = {};\n\n    this._nodes.forEach(key => {\n      const field = this.fields[key];\n      dft[key] = 'default' in field ? field.getDefault() : undefined;\n    });\n\n    return dft;\n  }\n\n  _getDefault() {\n    if ('default' in this.spec) {\n      return super._getDefault();\n    } // if there is no default set invent one\n\n\n    if (!this._nodes.length) {\n      return undefined;\n    }\n\n    return this.getDefaultFromShape();\n  }\n\n  shape(additions, excludes = []) {\n    let next = this.clone();\n    let fields = Object.assign(next.fields, additions);\n    next.fields = fields;\n    next._sortErrors = sortByKeyOrder(Object.keys(fields));\n\n    if (excludes.length) {\n      if (!Array.isArray(excludes[0])) excludes = [excludes];\n      let keys = excludes.map(([first, second]) => `${first}-${second}`);\n      next._excludedEdges = next._excludedEdges.concat(keys);\n    }\n\n    next._nodes = sortFields(fields, next._excludedEdges);\n    return next;\n  }\n\n  pick(keys) {\n    const picked = {};\n\n    for (const key of keys) {\n      if (this.fields[key]) picked[key] = this.fields[key];\n    }\n\n    return this.clone().withMutation(next => {\n      next.fields = {};\n      return next.shape(picked);\n    });\n  }\n\n  omit(keys) {\n    const next = this.clone();\n    const fields = next.fields;\n    next.fields = {};\n\n    for (const key of keys) {\n      delete fields[key];\n    }\n\n    return next.withMutation(next => next.shape(fields));\n  }\n\n  from(from, to, alias) {\n    let fromGetter = getter(from, true);\n    return this.transform(obj => {\n      if (obj == null) return obj;\n      let newObj = obj;\n\n      if (has(obj, from)) {\n        newObj = _extends({}, obj);\n        if (!alias) delete newObj[from];\n        newObj[to] = fromGetter(obj);\n      }\n\n      return newObj;\n    });\n  }\n\n  noUnknown(noAllow = true, message = locale.noUnknown) {\n    if (typeof noAllow === 'string') {\n      message = noAllow;\n      noAllow = true;\n    }\n\n    let next = this.test({\n      name: 'noUnknown',\n      exclusive: true,\n      message: message,\n\n      test(value) {\n        if (value == null) return true;\n        const unknownKeys = unknown(this.schema, value);\n        return !noAllow || unknownKeys.length === 0 || this.createError({\n          params: {\n            unknown: unknownKeys.join(', ')\n          }\n        });\n      }\n\n    });\n    next.spec.noUnknown = noAllow;\n    return next;\n  }\n\n  unknown(allow = true, message = locale.noUnknown) {\n    return this.noUnknown(!allow, message);\n  }\n\n  transformKeys(fn) {\n    return this.transform(obj => obj && mapKeys(obj, (_, key) => fn(key)));\n  }\n\n  camelCase() {\n    return this.transformKeys(camelCase);\n  }\n\n  snakeCase() {\n    return this.transformKeys(snakeCase);\n  }\n\n  constantCase() {\n    return this.transformKeys(key => snakeCase(key).toUpperCase());\n  }\n\n  describe() {\n    let base = super.describe();\n    base.fields = mapValues(this.fields, value => value.describe());\n    return base;\n  }\n\n}\nexport function create(spec) {\n  return new ObjectSchema(spec);\n}\ncreate.prototype = ObjectSchema.prototype;"]},"metadata":{},"sourceType":"module"}